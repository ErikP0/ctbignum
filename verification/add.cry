type Bigint n w = [n][w]
// mimics our C++ big_int type

upcast : {out,in} (fin in, fin out, out>=in) => [in] -> [out]
upcast a = ((0:[(out-in)]) # a)
// padd an existing variable with zeros such that it has 
// bit length equal to <out>

// reference implementation of big num addition
add_ref : {n, w} (fin n, fin w, (1 + n) * w >= 2) => Bigint n w -> Bigint n w -> Bigint (n+1) w
add_ref a b = num_to_bigint`{n+1,w}((bigint_to_num`{out=(n+1)*w} a) + (bigint_to_num`{out=(n+1)*w} b))
// algorithm:
//  1 - convert a and b (bigints) to Cryptol words of sufficient length, 
//  2 - perform addition using Cryptol's bignum addition
//  3 - convert back to bigint


// conversion from a number to a big int and vice versa
bigint_to_num : {n,w,out} (fin n, fin w, fin out, out >= width w, out >=2, out >= n*w, out >= w ) => Bigint n w -> [out]
bigint_to_num limbs = sums ! 0
  where sums = [ 0 ] # [ 2^^(`w) * s + (upcast`{out} x) | x <- limbs | s <- sums ]

num_to_bigint : {n,w} (fin n, fin w, n>=1,n*w >=2) => [n*w] -> Bigint n w  
num_to_bigint num = reverse( drop`{1} [(x@1)!!(reverse [0 .. w-1]:[_][width w]) | x <-xs] )
  where xs = [[num,0]] # [ [x@0 / (2:[n*w])^^(`w), x@0 % (2:[n*w])^^(`w) ] | x <- xs | y <- ([1 .. n]:[_][width n])]
